---
output:
  pdf_document:
    toc: false
    number_sections: true
  html_document:
    toc: true
    toc_depth: 5
---

\pagenumbering{gobble}

\begin{titlepage}
\centering
\vspace*{1cm}

\includegraphics[width=0.35\textwidth]{img/uib.png}\par
\vspace{1.5cm}

{\LARGE\bfseries 21746 - Data Mining\par}
\vspace{0.3cm}
{\LARGE\bfseries Final Project\par}
\vspace{0.8cm}
{\Large Steam Successful Indie Games Study\par}

\vspace{1.8cm}

{\large
Iván Pulgar Rodas\\
Jordi Sevilla Marí\\
Nahuel Vazquez\\
Yelyzaveta Denysova\\
Xiaozhe Cheng\\
Gabriel Oliver Artigues\\
Arturo Mus Mejías\par}

\vfill
{\large 2026-01-10\par}
\end{titlepage}

\clearpage
\pagenumbering{gobble}
\tableofcontents
\clearpage

\pagenumbering{arabic}
\setcounter{page}{1}


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)

# Core data manipulation
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)

# Dates & time
library(lubridate)

# Plotting
library(ggplot2)
library(scales)

# Association rules (what you already used)
library(arules)
library(arulesViz)

# Tidy evaluation (used in helpers)
library(rlang)
library(knitr)
library(tibble)

steam = read.csv("data/kaggle_march2025_full.csv", stringsAsFactors = FALSE, na.strings = FALSE)
```

# Introduction

```{r, include=FALSE}
# **IMPORTANTE**: Para cuando hagamos la presentación/pdf estaría bien comentar (el profesor dijo que lo valorará positivamente) el proceso de investigación para saber que significa cada variable, yo por ahora (a parte de la página de Kaggle) he encontrado esto <https://github.com/FronkonGames/Steam-Games-Scraper>

# **NOTA**: Esta no debería serla versión definitiva, creo que explicar 47 variables se nos va de tamño que flipas, lo he hecho por si os sirviera o por si al final si que dejamos la explicación de todas, en cualquier caso he hecho un drop de columnas que yo he creído que no ibamos a usar, una vez vayais acabando lo vuestro voy viendo a ver cuales usais

#TODO: Xiao arregla el error de `relative_growth_df`
```

## Explanation of the Attributes

The dataset we will be working with contains a total number of 94948 observations and 47 columns or variables. The columns that will be used are described bellow:

-   **`appid`**: Unique idetnifier of the game on Steam. [num]
-   **`name`**: Name of the game. [text]
-   **`released_date``**: Represents the date where the game was released. [time]
-   **`required_age``**: Corresponds to the minimum age required to play the game. [num]
-   **`price`**: How much the game costs. If its 0 it means that the game is Free to Play. [num]
-   **`dlc_count`**: Ammount of DLCs (Downloadable Contents) the game has. [num]
-   **`suppport_url`**: URL to the support page of the game. [text]
-   **`windows`**: Determines if the game runs in windows. [categorical]
-   **`mac`**: Determines if the game runs in mac. [categorical]
-   **`linux`**: Determines if the game runs in linux. [categorical]
-   **`metacritic_score`**: Metacritic score based on critcical reviews (reviews from professionalss). By performing an investigation we think that an score of 0 means that when the scraping of the data was done there where no reviews for that game yet. [num]
-   **`achievements`**: Number of achievements the game has. [num]
-   **`recommendations``**: Ammount of user recommendations. [num]
-   **`supported_languages`**: List of languages that the game supports.[**NO SÉ QUE CATEGORÍA DARLE**]
-   **`packages`**: Avaliable packages for the game. It contains the name and a description of the package and the names, descriptions and subprices of the subpackages. [**LO MISMO QUE ARRIBA**]
-   **`Developers`**: List of developers associated with the game. [**LO MISMO QUE ARRIBA**]
-   **`publishers`**: List of publishers associated with the game. [**LO MISMO QUE ARRIBA**]
-   **`categories`**: List of categories that the game has. [**LO MISMO QUE ARRIBA**]
-   **`genres`**: List of genres that the game belongs to. [**LO MISMO QUE ARRIBA**]
-   **`positive`**: Ammount of positive votes the game has. [num]
-   **`negative`**: Ammount of negative votes the game has. [num]
-   **`estimated_owners`**: Estimated owners of the game. [text]
-   **`average_playtime_forever`**: Average playtime since March 2009 measured in minutes. [num]
-   **`average_playtime_2weeks`**: Average playtime in the last two weeks measured in minutes. [num]
-   **`median_playtime_forever`**: Median playtime since March 2009 measured in minutes. [num]
-   **`median_playtime_2weeks`**: Median playtime in the last two weeks measured in minutes.[num]
-   **`peak_ccu`**: Number of current users playing the day before the data was scrapped. [num]
-   **`tags`**: List of tags the game has with its name and its key. [**NO SE QUE CATEGORIA DARLE**]
-   **`pct_pos_total`**: Percentage of all reviews that are positive. [num]
-   **`num_reviews_total`**: Nummber of the total reviews the game has. [num]

## Objectives

**TODO: ADD OBJECTIVES OF STUDY**

# Procesing de data

General look of the dataset

```{r}
summary(steam)
```

Explanation of first looks of it, bad formatting, NA's, negative values...

## Handling of NA values

The attributes with missing values are:

```{r}
na_counts <- steam %>% summarise_all(~ sum(is.na(.)))

print(na_counts)
```

The columns with missing values are as follows:


```{r cleaning, echo = FALSE}
cleaned_steam <- steam %>%
  # Removed not relevant/duplicated/unused columns
  select(-detailed_description, -about_the_game, -short_description, -reviews, -header_image, -website, -support_url, -support_email, -metacritic_url, -notes, -full_audio_languages, -screenshots, -movies, -user_score, -score_rank, -discount, -pct_pos_recent, -num_reviews_recent) %>%
  # Remove games that contains "Playtest" in the name
  filter(!grepl("Playtest", name, ignore.case = TRUE)) %>%
  # Games with blank name
  filter(!is.na(name), name != "", name != " ") %>%
  # From the repeated games we keep with those that have the higher price and the higher amount of total reviews 
  arrange(name, desc(price), desc(num_reviews_total)) %>%
  group_by(name) %>%
  slice(1) %>%
  ungroup() %>%
  # ReleaseDate treatment
  mutate(release_date = as.Date(release_date)) %>%
  filter(!is.na(release_date))
```

```{r, echo = FALSE}
add_range_minmax <- function(df, column, min_column, max_column) {
  column_quo <- enquo(column)

  df %>%
    mutate(
      "{min_column}" := as.integer(str_extract(!!column_quo, "^\\s*\\d+")),
      "{max_column}" := as.integer(str_extract(!!column_quo, "\\d+\\s*$"))
    )
}

cleaned_steam <- cleaned_steam %>%
  add_range_minmax(
    estimated_owners,
    "estimated_owners_min",
    "estimated_owners_max"
  ) %>%
  select(-estimated_owners)
```


LOs juegos con número de reseñas = -1 creemos que son porque el scrappear ha fallado durante su ejecución. Si vamos a trabajar con las reseñas podríamos decir en la presentación que vamos a probar de volver a intentar scrappear la información 

```{r info of the dataset, echo = FALSE}
str(cleaned_steam)
summary(cleaned_steam)
```

# Exploratory Data Analysis

```{r, echo = FALSE}
#Genres
action_genre <- c(
  # Action
  "Action", "Action-Adventure", "Action RPG", "Action Roguelike", "Action RTS",
  "Arcade", "Immersive Sim", "Metroidvania", "Musou", "Sandbox", "Survival",
  "Survival Horror", "MOBA")
shooter_genre<- c(
  # Shooter
  "Arena Shooter", "Battle Royale", "Boomer Shooter", "Bullet Hell", "Extraction Shooter",
  "FPS", "Hero Shooter", "Looter Shooter", "On-Rails Shooter", "Third-Person Shooter",
  "Top-Down Shooter", "Twin Stick Shooter", "Vehicular Combat", "Naval Combat",
  "Combat Racing")
roguelike_genre <- c(
  # Roguelike
  "Rogue-like", "Rogue-lite", "Roguevania", "Traditional Roguelike",
  "Roguelike Deckbuilder", "Mystery Dungeon")
RPG_genre <- c(
  # RPG
  "RPG", "JRPG", "CRPG", "Strategy RPG", "Tactical RPG", "Otome", 
  "Dating Sim", "Visual Novel", "Interactive Fiction", "Text-Based", 
  "MMORPG", "MMO")
strategy_genre <- c(
  # Strategy
  "Strategy", "4X", "Grand Strategy", "RTS", "Real Time Tactics",
  "Turn-Based Strategy", "Tactical", "Tabletop", "Wargame", "Political Sim",
  "God Game", "Management", "Colony Sim", "City Builder", "Shop Keeper",
  "Tower Defense", "Creature Collector")
simulation_genre <- c(
  # Simulation
  "Simulation", "Automobile Sim", "Farming Sim", "Medical Sim",
  "Hobby Sim", "Life Sim", "Space Sim", "Outbreak Sim")
sport_genre <- c(
  # Sports
  "Sports", "Baseball", "Basketball", "Bowling", "Boxing", "BMX", "Cricket",
  "Football", "Football (American)", "Football (Soccer)", "Soccer",
  "Golf", "Hockey", "Mini Golf", "Motocross", "Pool", "Racing", "Rugby",
  "Skateboarding", "Skating", "Skiing", "Snowboarding", "Snooker", "Tennis",
  "Volleyball", "Wrestling", "Driving")
fighting_genre <- c(
  # Fighting
  "2D Fighter", "3D Fighter", "Fighting", "Hack and Slash", "Souls-like")
platformer_genre <- c(
  # Platformers & runners 
  "Platformer", "2D Platformer", "3D Platformer", "Precision Platformer",
  "Runner", "Open World Survival Craft")
tabletop_genre <- c(
  # Puzzle, logic, board & card games
  "Puzzle", "Puzzle-Platformer", "Logic", "Mahjong",
  "Match 3", "Tile-Matching", "Sokoban", "Solitaire", "Trivia",
  "Board Game", "Card Game", "Trading Card Game", "Hidden Object",
  "Escape Room", "Chess", "Word Game", "Point & Click")
casual_genre <- c(
  #  Casual / idle
  "Casual", "Idler", "Clicker", "Auto Battler", "Party Game", "Pinball")
horror_genre <- c(
  # Horror
  "Horror", "Psychological Horror")
music_genre <- c(
  # Music & rhythm
  "Music", "Rhythm", "Typing")
walking_sim_genre <- c(
  # Walking
  "Walking Simulator", "FMV")

genres <- list(
  action = action_genre,
  shooter = shooter_genre,
  roguelike = roguelike_genre,
  RPG = RPG_genre,
  strategy = strategy_genre,
  simulation = simulation_genre,
  sport = sport_genre,
  fighting = fighting_genre,
  platformer = platformer_genre,
  tabletop = tabletop_genre,
  casual = casual_genre,
  horror = horror_genre,
  music = music_genre,
  walking_sim = walking_sim_genre
)
```

```{r, echo = FALSE}
make_group_flag <- function(data, values, group_name,
                            categories_col = "categories",
                            genres_col = "genres",
                            tags_col = "tags") {

  parse_list_row <- function(x) {
    x <- as.character(x)
    if (is.na(x) || x == "[]") return(character(0))
    x <- gsub("^\\[|\\]$", "", x)
    x <- gsub("['\"]", "", x)
    vals <- trimws(strsplit(x, ",", fixed = TRUE)[[1]])
    vals[vals != ""]
  }

  parse_dict_row <- function(x) {
    x <- as.character(x)
    if (is.na(x) || x == "[]" || x == "" || x == "{}") return(character(0))

    m <- gregexpr("(['\"])([^'\"]+)\\1\\s*:", x, perl = TRUE)
    pieces <- regmatches(x, m)[[1]]
    if (length(pieces) == 0) return(character(0))

    keys <- sub("^(['\"])([^'\"]+)\\1\\s*:$", "\\2", pieces, perl = TRUE)
    keys <- trimws(keys)
    keys[keys != ""]
  }

  values_set <- trimws(unique(values))

  tokens_list <- lapply(seq_len(nrow(data)), function(i) {
    cats <- parse_list_row(data[[categories_col]][i])
    gens <- parse_list_row(data[[genres_col]][i])
    tgs  <- parse_dict_row(data[[tags_col]][i])
    tokens <- unique(c(cats, gens, tgs))
    tokens
  })

  flag <- vapply(tokens_list, function(tokens) any(tokens %in% values_set), logical(1))

  data[[group_name]] <- flag

  data
}
```

```{r, echo = FALSE}

file <- file.path("data", "genre_group_coded_steam.rds")

if (file.exists(file)) {
  genre_group_coded_steam <- readRDS(file)
} else {
  dir.create("data", showWarnings = FALSE, recursive = TRUE)
  genre_group_coded_steam <- cleaned_steam

  for (g_name in names(genres)) {
    genre_group_coded_steam <- make_group_flag(
      genre_group_coded_steam, 
      genres[[g_name]], 
      g_name
    )
  }
  
  genre_group_coded_steam <- genre_group_coded_steam %>% select(-tags, -categories, -genres)
  
  saveRDS(genre_group_coded_steam, file)
}
```

```{r, echo = FALSE}
# 1. Prepare the trend data
genre_trend_df <- genre_group_coded_steam %>%
  # Extract year and handle potential date formats
  mutate(release_year = as.numeric(str_extract(release_date, "\\d{4}"))) %>%
  # Filter for realistic timeframe
  filter(!is.na(release_year), release_year >= 2010, release_year <= 2024) %>%
  # Select the release year and the genre group columns we just created
  select(release_year, all_of(names(genres))) %>%
  # Reshape to long format
  pivot_longer(cols = -release_year, names_to = "Genre", values_to = "HasGenre") %>%
  # Count occurrences per year
  filter(HasGenre == TRUE) %>%
  group_by(release_year, Genre) %>%
  summarise(Count = n(), .groups = 'drop')
```

```{r, echo = FALSE}
yearly_baseline <- genre_group_coded_steam %>%
  mutate(release_year = as.numeric(str_extract(release_date, "\\d{4}"))) %>%
  filter(!is.na(release_year), release_year >= 2010, release_year <= 2024) %>%
  group_by(release_year) %>%
  summarise(Total_Games_Yearly = n(), .groups = 'drop')
```

```{r, echo = FALSE}
market_share <- genre_trend_df %>%
  left_join(yearly_baseline, by = "release_year") %>%
  mutate(Market_Share = (Count / Total_Games_Yearly) * 100)
```

```{r, echo = FALSE}
genre_grow <- market_share %>%
  arrange(Genre, release_year) %>% 
  group_by(Genre) %>%
  mutate(
    yearly_change = Market_Share - lag(Market_Share),
    abs_yearly_change = abs(yearly_change)
  ) %>%
  summarize(
    Total_Volatility = sum(abs_yearly_change, na.rm = TRUE),
    Net_Growth = last(Market_Share) - first(Market_Share)
  ) %>%
  arrange(desc(Total_Volatility))

print(genre_grow)
```

```{r, echo = FALSE}
ggplot(genre_grow, aes(x = reorder(Genre, Net_Growth), y = Net_Growth, fill = Net_Growth > 0)) +
  geom_col() +
  coord_flip() +
  scale_fill_manual(values = c("TRUE" = "steelblue", "FALSE" = "salmon"), 
                    labels = c("Negative", "Positive"), 
                    name = "Growth Type") +
  labs(
    title = "Top 5 and Bottom 5 Genres by Net Growth",
    subtitle = "Comparing highest vs. lowest performance",
    x = "Genre",
    y = "Net Growth (%)"
  ) +
  theme_minimal()
```

```{r, echo = FALSE}
ggplot(relative_growth_df %>% filter(Genre %in% positive_genres), 
       aes(x = release_year, y = Market_Share, color = Genre)) +
  geom_line(linewidth = 1.2, alpha = 0.8) +
  geom_point(size = 1.5) +
  theme_minimal() +
  labs(
    title = "Market Share Trend: Positive Growth Genres",
    subtitle = "Genres that increased their market footprint",
    x = "Year of Release",
    y = "Market Share (%)",
    color = "Genre"
  ) +
  scale_x_continuous(breaks = seq(2010, 2024, by = 2))
```

```{r, echo = FALSE}
ggplot(relative_growth_df %>% filter(Genre %in% negative_genres), 
       aes(x = release_year, y = Market_Share, color = Genre)) +
  geom_line(linewidth = 1.2, alpha = 0.8) +
  geom_point(size = 1.5) +
  theme_minimal() +
  labs(
    title = "Market Share Trend: Negative Growth Genres",
    subtitle = "Genres that decreased their market footprint",
    x = "Year of Release",
    y = "Market Share (%)",
    color = "Genre"
  ) +
  scale_x_continuous(breaks = seq(2010, 2024, by = 2))
```

```{r, echo = FALSE}
# 1. Filter for games that have actually been played
played_games <- genre_group_coded_steam %>%
  filter(average_playtime_forever > 0)
```

```{r, echo = FALSE}
genre_playtime_stats <- played_games %>%
  # Select playtime and the specific genre group columns created earlier
  select(average_playtime_forever, all_of(names(genres))) %>%
  
  # Reshape to long format: one row per (Game, Genre Group)
  pivot_longer(
    cols = all_of(names(genres)), 
    names_to = "Genre_Group", 
    values_to = "HasGenre"
  ) %>%
  
  # Keep only the rows where the game belongs to that genre group
  filter(HasGenre == TRUE) %>%
  
  # Group by the custom genre groups and calculate stats
  group_by(Genre_Group) %>%
  summarise(
    Mean_Playtime = mean(average_playtime_forever, na.rm = TRUE),
    Median_Playtime = median(average_playtime_forever, na.rm = TRUE),
    Total_Games = n(),
    .groups = 'drop'
  ) %>%
  
  # Sort by Median Playtime (usually better for playtime due to outliers)
  arrange(desc(Median_Playtime))
```

```{r, echo = FALSE}
# 3. View the summary table
print(genre_playtime_stats)
```

```{r, echo = FALSE}
nrow(played_games)
```

```{r, echo = FALSE}
# 4. Visualize the results
# We use Median here as it's more representative of the "typical" player experience
ggplot(genre_playtime_stats, aes(x = reorder(Genre_Group, Median_Playtime), y = Median_Playtime)) +
  geom_col(fill = "steelblue") + 
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Typical Playtime by Genre Group",
    subtitle = "Median Playtime (minutes) for games with recorded activity",
    x = "Genre Group",
    y = "Median Playtime (Minutes)"
  ) +
  geom_text(aes(label = round(Median_Playtime, 0)), hjust = -0.1, size = 3.5) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
```

```{r, echo = FALSE}
ggplot(genre_playtime_stats, aes(x = reorder(Genre_Group, Mean_Playtime), y = Mean_Playtime)) +
  geom_col(fill = "steelblue") + 
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Typical Playtime by Genre Group",
    subtitle = "Median Playtime (minutes) for games with recorded activity",
    x = "Genre Group",
    y = "Median Playtime (Minutes)"
  ) +
  geom_text(aes(label = round(Mean_Playtime, 0)), hjust = -0.1, size = 3.5) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
```




# Commonalities among successful indie games
```{r commonalities_setup, include=FALSE}
#-------------------------------------------------
# Funcion helpers
#-------------------------------------------------
get_unique_dict_keys <- function(x) {
  x <- x[x != "[]"]
  keys_list <- str_extract_all(x, "(?<=')[^']+(?='\\s*:)")
  keys <- trimws(unlist(keys_list, use.names = FALSE))
  keys <- keys[keys != ""]
  sort(unique(keys))
}

get_unique_list_values <- function(x) {
  x <- x[x != "[]"]
  x <- gsub("^\\[|\\]$", "", x) # quitar [ y ]
  x <- gsub("['\"]", "", x)# quitar ' y "
  
  elements <- strsplit(x, ",") # dividr por comas

  vals <- trimws(unlist(elements, use.names = FALSE)) # aplanar y trim
  vals <- vals[vals != ""]
  
  sort(unique(vals))
}

#-------------------------------------------------
# Segment remaining steam attributes:
#-------------------------------------------------
#Mechanics
resource_management_mechanic <- c(
  # Economy, building, resources
  "Base-Building", "Building", "Resource Management", "Inventory Management",
  "Crafting", "Automation", "Mining", "Farming")

customization_mechanic <- c(
  # Customization
  "Gun Customization", "Character Customization")
movement_mechanic <- c(
  # Movement
  "Stealth", "Parkour", "Swordplay", "Archery", "Sniper")
physics_mechanic <- c(
  # Physics
  "Physics", "Destruction")
failure_mechanic <- c(
  # Failure
  "Permadeath", "Perma Death")
procedural_mechanic <- c(
  # Procedural
  "Procedural Generation", "Music-Based Procedural Generation")
turn_mechanic <- c(
  # Turns
  "Turn-Based", "Turn-Based Combat", "Turn-Based Tactics",
  "Real-Time", "Real-Time with Pause",
  "Time Manipulation", "Time Management", "Time Attack")
spatial_rules_mechanic <- c(
  # Spatial rules
  "Grid-Based Movement", "Hex Grid")
quicktime_events_mechanic <- c(
  # QTE
  "Quick-Time Events")
narrative_mechanic <- c(
  # Narrative logic
  "Choices Matter", "Multiple Endings", "Nonlinear")
exploration_mechanic <- c(
  # Exploration & structure
  "Exploration", "Dungeon Crawler", "Collectathon",
  "Boss Rush", "Side Scroller", "Loot")
social_mechanic <- c(
  # Social deduction
  "Social Deduction")
card_mechanic <- c(
  # Card/Deck mechanics
  "Deckbuilding", "Card Battler")
programming_mechanic <- c(
  # Programming
  "Programming", "Coding")
economy_mechanic <- c(
  # Economy
  "Trading", "Economy", "Capitalism",
  "Diplomacy")
modding_mechanic <- c(
  # Modding / creation
  "Level Editor", "Moddable", "Mod")
tutorial_mechanic <- c(
  # Tutorial
  "Tutorial")

mechanics <- list(
  resource_management = resource_management_mechanic, 
  customization = customization_mechanic, 
  movement = movement_mechanic, 
  physics = physics_mechanic, 
  failure = failure_mechanic, 
  procedural = procedural_mechanic, 
  turn = turn_mechanic,
  spatial_rules = spatial_rules_mechanic,
  quicktime_events = quicktime_events_mechanic,
  narrative = narrative_mechanic,
  exploration = exploration_mechanic,
  social = social_mechanic,
  card = card_mechanic,
  programming = programming_mechanic,
  economy = economy_mechanic,
  modding = modding_mechanic,
  tutorial = tutorial_mechanic
)

# Characteristics
camera_characteristic <- c(
  # Dimensionality & camera
  "2D", "2.5D", "3D",
  "Isometric", "Top-Down",
  "6DOF",
  "First-Person", "Third Person")

vr_characteristic <- c(
  # VR
  "VR", "VR Only", "Asymmetric VR")

players_characteristic <- c(
  # Player count / mode
  "Singleplayer",
  "Multiplayer", "Massively Multiplayer",
  "Co-op", "Local Co-Op", "Online Co-Op", "Co-op Campaign",
  "4 Player Local", "Split Screen")
team_characteristic <- c(
  # Team/role structure
  "PvP", "PvE", "Team-Based",
  "Asynchronous Multiplayer")
esports_characteristic <- c(
  # Competitive/e-sports
  "e-sports")

characteristics <- list(
  camera = camera_characteristic,
  vr = vr_characteristic,
  players = players_characteristic,
  team = team_characteristic,
  esports = esports_characteristic
)
```
Indie game development is high-risk: budgets are limited, marketing reach is uncertain, and audience discovery can be unpredictable. This section explores commonalities across successful indie games, with two practical goals:
* **Understand market audience:** identify what combinations of genres/mechanics tend to co-occur among games that reach larger audiences.
* **Reduce risk for game-making:** extract patterns that can guide design decisions without prescribing a single “correct” formula.


We focus on four questions:
* **Does genre matter?**
* **Do mechanics matter (especially in combination with genre)?**
* **Do game characteristics matter (e.g., camera, player modes, VR)?**
* **Does pricing matter (relationship with owners)?**

## Selecting indie games
Steam has done the hard work for us by including “Indie” as a genre/tag (and related tags such as “Crowdfunded” / “Kickstarter”). Given that these tags have been assigned by users world-wide, we can agree on these tags representing widely-considered indie games. We filter the dataset to games containing any of these signals in Genres, Tags or Categories.
```{r, echo = FALSE}
indie <- c("Crowdfunded", "Kickstarter", "Indie")
indie_pattern <- str_c(indie, collapse = "|")

indie_games <- steam %>% 
  filter(
    if_any(
      c(categories, genres, tags),
      ~ str_detect(.x, indie_pattern)
    )
  )
```

## Determining “successful” indie games
Determining “successful” indie games

“Success” is not directly labeled in the dataset, so we build an operational proxy based on market and engagement signals. The main goal of this step is to isolate a subset of indie games that consistently perform better than the rest, so that later sections (association rules and plots) focus on patterns that appear among higher-impact titles.

### Clustering approach
We cluster indie games using a set of numeric variables that capture outcomes and engagement (e.g., recommendations, reviews, playtime, peak CCU, owners/revenue estimates, price, and platform availability). Before fixing the final configuration, we experimented with multiple numbers of clusters:
* **2 clusters** (attempting to represent successful vs not successful)
* **3 clusters** (attempting to represent massively successful, successful and not successful)
* **4 clusters**
* **5 clusters**
* **10 clusters**

The best segmentation for interpretability and separation was obtained with 3 clusters.

In our dataset, representative examples of these mid/high clusters included games such as Deceit, Graveyard Keeper, Unturned (mid-tier), and Stardew Valley, Subnautica, Terraria (top-tier). These examples illustrate how the clustering captures meaningful outcome tiers rather than arbitrary partitions.

We implement the final clustering using k-means with k = 3 on standardized variables.
```{r, echo = FALSE}
indie_games_data <- indie_games %>%
  select(
    appid, name, price, dlc_count, windows, mac, linux,
    achievements, recommendations, supported_languages,
    positive, negative, estimated_owners,
    average_playtime_forever, median_playtime_forever,
    peak_ccu, pct_pos_total, num_reviews_total
  )

add_column_count <- function(df, column, new_col) {
  column_quo <- rlang::enquo(column)
  df %>%
    mutate(
      "{new_col}" := dplyr::case_when(
        !!column_quo == "[]" ~ 0L,
        TRUE ~ str_count(!!column_quo, "'") %/% 2L
      )
    )
}

indie_games_data <- indie_games_data %>%
  add_range_minmax(estimated_owners, "estimated_owners_min", "estimated_owners_max") %>%
  mutate(estimated_revenue = ((estimated_owners_min + estimated_owners_max) / 2) * price) %>%
  mutate(windows = as.integer(windows == "True")) %>%
  mutate(mac = as.integer(mac == "True")) %>%
  mutate(linux = as.integer(linux == "True")) %>%
  select(-estimated_owners)

indie_games_cluster <- indie_games_data %>%
  add_column_count(supported_languages, "languages_count") %>%
  select(-appid, -name, -supported_languages)

# Standardize continuous numeric features
indie_games_cluster <- indie_games_cluster %>%
  mutate(
    across(
      where(is.numeric) & !all_of(c("windows", "mac", "linux")),
      ~ as.numeric(scale(.))
    )
  )

# Final clustering choice: k = 3
km3 <- kmeans(indie_games_cluster, centers = 3, nstart = 50)
indie_games_data$success_cluster <- km3$cluster

# Identify which variable best separates clusters (highest ANOVA F-statistic)
vars <- c(
  "price", "dlc_count", "windows", "mac", "linux",
  "achievements", "recommendations",
  "positive", "negative",
  "average_playtime_forever", "median_playtime_forever",
  "peak_ccu",
  "pct_pos_total", "num_reviews_total",
  "estimated_owners_min", "estimated_owners_max",
  "estimated_revenue"
)

f_stats <- purrr::map_dbl(vars, function(v) {
  form <- as.formula(paste(v, "~ success_cluster"))
  aov_res <- aov(form, data = indie_games_data)
  summary(aov_res)[[1]][["F value"]][1]
})

most_discriminative_var <- vars[which.max(f_stats)]

cluster_summary <- indie_games_data %>%
  group_by(success_cluster) %>%
  summarise(
    mean_val = mean(as.numeric(.data[[most_discriminative_var]]), na.rm = TRUE),
    median_val = median(as.numeric(.data[[most_discriminative_var]]), na.rm = TRUE),
    n_games = n(),
    .groups = "drop"
  ) %>%
  arrange(mean_val)

# Assign human-readable tier labels based on the mean of the discriminant variable
cluster_summary <- cluster_summary %>%
  mutate(tier = c("Unsuccessful", "Somewhat successful", "Highly successful"))

cluster_labels <- setNames(cluster_summary$tier, cluster_summary$success_cluster)

# Define “successful” as the upper two clusters (mid + top tiers)
top2_clusters <- cluster_summary %>%
  slice_tail(n = 2) %>%
  pull(success_cluster)

indie_games <- indie_games %>%
  mutate(success_cluster = km3$cluster) %>%
  mutate(successful = success_cluster %in% top2_clusters) %>%
  select(-success_cluster)

success_n <- sum(indie_games$successful, na.rm = TRUE)
success_rate <- success_n / nrow(indie_games)
```

Using this proxy, `r scales::comma(success_n)` games are labeled successful (`r scales::percent(success_rate, accuracy = 0.1)` of indie games).

### Validation: do clusters separate meaningfully?
Because clustering is unsupervised, we validate quality using a simple but practical hypothesis:
*If the most discriminant variable is unable to separate the clusters, then the clustering is likely not meaningful.*
We therefore compute the variable that best differentiates the clusters (highest ANOVA F-statistic) and verify that it produces a clear separation across groups.

In our case, the most discriminant variable is `r most_discriminative_var` and it produces a clean ordering between the three clusters, which supports using this partition in the rest of the report.

As an additional sanity check, we compute a global silhouette score on a random sample of games in the standardized feature space. Silhouette values closer to 1 indicate well-separated clusters, values near 0 indicate overlap, and negative values suggest poor assignments.
```{r, echo = TRUE}
n_all <- nrow(indie_games_cluster)
idx <- sample(seq_len(n_all), size = min(5000, n_all))

x_s <- as.matrix(indie_games_cluster[idx, , drop = FALSE])
cl_s <- km3$cluster[idx]

# Euclidean distance on standardized features
D <- dist(x_s)

sil <- cluster::silhouette(cl_s, D)
silhouette_avg <- mean(sil[, "sil_width"])
```
The average silhouette score on the sample is `r round(silhouette_avg, 3)`.

### Cluster interpretation
The figure below summarizes the mean and median values of the discriminant variable (`r most_discriminative_var`) across clusters, alongside the number of games per tier.

In our run, the discriminant variable is `r most_discriminative_var`, which acts as a strong quality/visibility signal: the unsuccessful long-tail cluster concentrates near the lowest values, while the two top-tier cluster achieves the highest values, separating games with limited traction from games with stable success.
```{r}
# Plot the cluster summary (mean + median of the most discriminant variable)
cluster_summary_long <- cluster_summary %>%
  select(success_cluster, tier, mean_val, median_val, n_games) %>%
  tidyr::pivot_longer(
    cols = c(mean_val, median_val),
    names_to = "statistic",
    values_to = "value"
  ) %>%
  mutate(
    statistic = dplyr::recode(statistic, mean_val = "Mean", median_val = "Median"),
    cluster = paste0("Cluster ", success_cluster, " — ", tier)
  )

cluster_summary_long %>%
  ggplot(aes(x = reorder(cluster, value), y = value, shape = statistic, group = statistic)) +
  geom_point(size = 3) +
  geom_line() +
  geom_text(
    data = cluster_summary %>%
      mutate(cluster = paste0("Cluster ", success_cluster, " — ", tier)),
    aes(x = reorder(cluster, mean_val), y = mean_val, label = paste0("n=", n_games)),
    inherit.aes = FALSE,
    vjust = -0.8,
    size = 3
  ) +
  scale_y_continuous(breaks = pretty_breaks(), expand = expansion(mult = c(0.05, 0.18))) +
  labs(
    title = paste("Cluster summary using", most_discriminative_var),
    subtitle = "Points show mean and median of the most discriminant variable per cluster",
    x = NULL,
    y = paste("Value of", most_discriminative_var)
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 15, hjust = 1))
```
A key takeaway from the cluster sizes is that the distribution is highly imbalanced: a large share of games are concentrated in the lower-to-mid tiers, while the top tier contains only a small number of games. In this run, the lowest tier accounts for `r scales::percent(cluster_summary$prop[1], accuracy = 0.1)`, whereas the highest tier represents only `r scales::percent(tail(cluster_summary$prop, 1), accuracy = 0.1)` of indie games.
```{r}
# Plot number of games per cluster (count distribution)
cluster_summary %>%
  mutate(cluster = paste0("Cluster ", success_cluster, " — ", tier)) %>%
  ggplot(aes(x = reorder(cluster, n_games), y = n_games)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Number of games per cluster",
    x = NULL,
    y = "Count of games"
  ) +
  theme_minimal()
```



# Can a single game have enough influence to make other games have its tag?

## Game study: Slay the Spire (Roguelike Deckbuilder)


```{r, echo = FALSE}
ref_game_SlayTheSpire <- cleaned_steam %>% filter(appid == 646570) %>% slice(1)

ref_game_SlayTheSpire$name
ref_game_SlayTheSpire$release_date
```


```{r, echo = FALSE}
library(lubridate)

month_index <- function(d) {
  year(d) * 12 + month(d)
}

build_tag_timeseries_month <- function(games, tag_pattern, ref_date,
                                       window_months = 60,
                                       max_date = as.Date("2025-02-28")) {

  ref_date <- as.Date(ref_date)
  max_date <- as.Date(max_date)

  ref_mi <- month_index(ref_date)
  max_mi <- month_index(max_date)

  t_min <- -window_months
  t_max <- min(window_months, max_mi - ref_mi)

  df_binned <- games %>%
    dplyr::filter(stringr::str_detect(tags, stringr::fixed(tag_pattern))) %>%
    dplyr::mutate(
      release_date = as.Date(release_date),
      t = month_index(release_date) - ref_mi
    ) %>%
    dplyr::filter(t >= t_min, t <= t_max) %>%
    dplyr::count(t, name = "freq")

  full_bins <- tibble::tibble(t = seq(t_min, t_max, by = 1))

  full_bins %>%
    dplyr::left_join(df_binned, by = "t") %>%
    dplyr::mutate(
      freq = tidyr::replace_na(freq, 0L),
      post = as.integer(t > 0)
    ) %>%
    dplyr::arrange(t)
}


```


```{r, echo = FALSE}
ts_slayTheSpire <- build_tag_timeseries_month(
  games = cleaned_steam,
  tag_pattern = "Roguelike Deckbuilder",
  ref_date = ref_game_SlayTheSpire$release_date,
  window_months = 84 # ±7 years
)

# Piecewise model (pre trend + post jump + slope change)
m_slayTheSpire <- lm(freq ~ t + post + t:post, data = ts_slayTheSpire)
summary(m_slayTheSpire)

```

```{r, echo = FALSE}
ggplot(ts_slayTheSpire, aes(x = t, y = freq)) +
  geom_point(alpha = 0.7) +
  geom_smooth(data = subset(ts_slayTheSpire, t < 0), method = "lm", se = FALSE, formula = y ~ x) +
  geom_smooth(data = subset(ts_slayTheSpire, t > 0), method = "lm", se = FALSE, formula = y ~ x) +
  scale_x_continuous(
    breaks = seq(from = min(ts_slayTheSpire$t),to = max(ts_slayTheSpire$t), by = 12),
    labels = function(x) x / 12,
    minor_breaks = NULL
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Tag adoption around Slay the Spire launch",
    subtitle = "Tag: Roguelike Deckbuilder — months relative to launch (t=0)",
    x = "Months relative to launch (t=0)",
    y = "Number of released games with the tag RogueLike DeckBuilding(per month)"
  ) +
  theme_minimal()

```


```{r, echo = FALSE}
build_global_timeseries_month <- function(games, ref_date,
                                          window_months = 60,
                                          max_date = as.Date("2025-02-28")) {

  ref_date <- as.Date(ref_date)
  max_date <- as.Date(max_date)

  ref_mi <- month_index(ref_date)
  max_mi <- month_index(max_date)

  t_min <- -window_months
  t_max <- min(window_months, max_mi - ref_mi)

  df_binned <- games %>%
    dplyr::mutate(
      release_date = as.Date(release_date),
      t = month_index(release_date) - ref_mi
    ) %>%
    dplyr::filter(t >= t_min, t <= t_max) %>%
    dplyr::count(t, name = "freq")

  full_bins <- tibble::tibble(t = seq(t_min, t_max, by = 1))

  full_bins %>%
    dplyr::left_join(df_binned, by = "t") %>%
    dplyr::mutate(
      freq = tidyr::replace_na(freq, 0L),
      post = as.integer(t > 0)
    ) %>%
    dplyr::arrange(t)
}

```

```{r, echo = FALSE}
# Global baseline (all games)
ts_global <- build_global_timeseries_month(
  games = cleaned_steam,
  ref_date = ref_game_SlayTheSpire$release_date,
  window_months = 84
)

```

```{r, echo = FALSE}
m_tag <- lm(freq ~ t + post + t:post, data = ts_slayTheSpire)
m_global <- lm(freq ~ t + post + t:post, data = ts_global)

summary(m_tag)
summary(m_global)

```

```{r, echo = FALSE}
combined <- bind_rows(
  ts_slayTheSpire %>% mutate(type = "Roguelike Deckbuilder", series = "tag"),
  ts_global %>% mutate(type = "All games", series = "global")
)

ggplot(combined, aes(x = t, y = freq, color = type)) +
  geom_point(alpha = 0.6) +
  geom_smooth(data = subset(combined, t < 0), method = "lm", se = FALSE, formula = y ~ x) +
  geom_smooth(data = subset(combined, t > 0), method = "lm", se = FALSE, formula = y ~ x) +
  scale_x_continuous(
    breaks = seq(from = min(combined$t),to = max(combined$t), by = 12),
    labels = function(x) x / 12,
    minor_breaks = NULL
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Slope comparison around Slay the Spire launch",
    subtitle = "Target tag vs overall Steam release trend (monthly bins)",
    x = "Months relative to launch (t = 0)",
    y = "Number of released games per month",
    color = "Series"
  ) +
  theme_minimal()

```

```{r, echo = FALSE}

m_diff <- lm(freq ~ t * post * series, data = combined)
summary(m_diff)

```

## Game Study: The Binding Of Isaac + The Binding Of Isaac Rebirth (Roguelike)

```{r, echo = FALSE}
ref_game_BindingOfIsaac <- cleaned_steam %>% filter(appid == 113200) %>% slice(1)

ref_game_BindingOfIsaac$name
ref_game_BindingOfIsaac$release_date

ts_BindingOfIsaac <- build_tag_timeseries_month(
  games = cleaned_steam,
  tag_pattern = "Roguelike",
  ref_date = ref_game_BindingOfIsaac$release_date,
  window_months = 168 # ±14 years
)

ref_game_BindingOfIsaacRebirth <- cleaned_steam %>% filter(appid == 250900) %>% slice(1)

ref_game_BindingOfIsaacRebirth$name
ref_game_BindingOfIsaacRebirth$release_date


ts_BindingOfIsaacRebirth <- build_tag_timeseries_month(
  games = cleaned_steam,
  tag_pattern = "Roguelike",
  ref_date = ref_game_BindingOfIsaacRebirth$release_date,
  window_months = 132 # ±11 years
)
```

```{r, echo = FALSE}
ggplot(ts_BindingOfIsaac, aes(x = t, y = freq)) +
  geom_point(alpha = 0.7) +
  geom_smooth(data = subset(ts_BindingOfIsaac, t < 0), method = "lm", se = FALSE, formula = y ~ x) +
  geom_smooth(data = subset(ts_BindingOfIsaac, t > 0), method = "lm", se = FALSE, formula = y ~ x) +
  scale_x_continuous(
    breaks = seq(from = min(ts_BindingOfIsaac$t),to = max(ts_BindingOfIsaac$t), by = 12),
    labels = function(x) x / 12,
    minor_breaks = NULL
  ) +
  coord_cartesian(ylim = c(0, 200)) +
  scale_y_continuous(
    breaks = seq(0, 200, by = 25)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Tag adoption around The Binding Of Isaac",
    subtitle = "Tag: Roguelike — months relative to launch (t=0)",
    x = "Years relative to launch (t = 0)",
    y = "Number of released games",
  ) +
  theme_minimal()

```

```{r, echo = FALSE}
# Global baseline (all games)
ts_global <- build_global_timeseries_month(
  games = cleaned_steam,
  ref_date = ref_game_BindingOfIsaac$release_date,
  window_months = 168
)

plot_df <- bind_rows(
  ts_BindingOfIsaac %>% mutate(type = "Roguelike"),
  ts_global %>% mutate(type = "All games")
)
```


```{r, echo = FALSE}
ggplot(plot_df, aes(x = t, y = freq, color = type)) +
  geom_point(alpha = 0.6) +
  geom_smooth(data = subset(plot_df, t < 0), method = "lm", se = FALSE, formula = y ~ x) +
  geom_smooth(data = subset(plot_df, t > 0), method = "lm", se = FALSE, formula = y ~ x) +
  scale_x_continuous(
    breaks = seq(from = min(plot_df$t),to = max(plot_df$t), by = 12),
    labels = function(x) x / 12,
    minor_breaks = NULL
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Slope comparison around The BInding of Isaac launch",
    subtitle = "Target tag vs overall Steam release trend (monthly bins)",
    x = "Years relative to launch (t = 0)",
    y = "Number of released games",
    color = "Series"
  ) +
  theme_minimal()

```


```{r, echo = FALSE}
ggplot(ts_BindingOfIsaacRebirth, aes(x = t, y = freq)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE, formula = y ~ x, data = subset(ts_BindingOfIsaacRebirth, t < 0)) +
  geom_smooth(method = "lm", se = FALSE, formula = y ~ x, data = subset(ts_BindingOfIsaacRebirth, t > 0)) +
  scale_x_continuous(
    breaks = seq(from = min(ts_BindingOfIsaacRebirth$t),to = max(ts_BindingOfIsaacRebirth$t), by = 12),
    labels = function(x) x / 12,
    minor_breaks = NULL
  ) +
  coord_cartesian(ylim = c(0, 200)) +
  scale_y_continuous(
    breaks = seq(0, 200, by = 25)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Tag adoption around The Binding Of Isaac REBIRTH",
    subtitle = "Tag: Roguelike — months relative to launch (t=0)",
    x = "Years relative to launch (t = 0)",
    y = "Number of released games",
  ) +
  theme_minimal()

```

```{r, echo = FALSE}
# Global baseline (all games)
ts_global <- build_global_timeseries_month(
  games = cleaned_steam,
  ref_date = ref_game_BindingOfIsaacRebirth$release_date,
  window_months = 120
)

plot_df <- bind_rows(
  ts_BindingOfIsaacRebirth %>% mutate(type = "Roguelike"),
  ts_global %>% mutate(type = "All games")
)
```


```{r, echo = FALSE}
ggplot(plot_df, aes(x = t, y = freq, color = type)) +
  geom_point(alpha = 0.6) +
  geom_smooth(data = subset(plot_df, t < 0), method = "lm", se = FALSE) +
  geom_smooth(data = subset(plot_df, t > 0), method = "lm", se = FALSE) +
  scale_x_continuous(
    breaks = seq(from = min(ts_BindingOfIsaacRebirth$t),to = max(ts_BindingOfIsaacRebirth$t), by = 12),
    labels = function(x) x / 12,
    minor_breaks = NULL
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Slope comparison around The BInding of Isaac Rebirth launch",
    subtitle = "Roguelike tag vs overall Steam releases",
    x = "Years relative to launch (t = 0)",
    y = "Number of released games",
    color = "Series"
  ) +
  theme_minimal()

```


```{r, echo = FALSE}
ref_game_Terraria <- cleaned_steam %>% filter(appid == 105600) %>% slice(1)

ref_game_Terraria$name
ref_game_Terraria$release_date


ts_Terraria <- build_tag_timeseries_month(
  games = cleaned_steam,
  tag_pattern = "Open World Survival Craft",
  ref_date = ref_game_Terraria$release_date,
  window_months = 168 # ±10 years
)

```

```{r, echo = FALSE}
ggplot(ts_Terraria, aes(x = t, y = freq)) +
  geom_point(alpha = 0.7) +
  geom_smooth(data = subset(ts_Terraria, t < 0), method = "lm", se = FALSE, formula = y ~ x) +
  geom_smooth(data = subset(ts_Terraria, t > 0), method = "lm", se = FALSE, formula = y ~ x) +
  scale_x_continuous(
    breaks = seq(from = min(ts_Terraria$t),to = max(ts_Terraria$t), by = 12),
    labels = function(x) x / 12,
    minor_breaks = NULL
  ) +
  coord_cartesian(ylim = c(0, 50)) +
  scale_y_continuous(
    breaks = seq(0, 50, by = 10)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    title = "Tag adoption around Terraria",
    subtitle = "Tag: Open World Survival Craft — months relative to launch (t=0)",
    x = "Years relative to launch (t = 0)",
    y = "Number of released games",
  ) +
  theme_minimal()

```