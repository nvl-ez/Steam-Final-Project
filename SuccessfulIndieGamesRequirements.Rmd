
```{r}
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
library(arules)
library(rlang)
library(ggplot2)
library(arulesViz)
library(scales)
```


```{r}
steam <- read.csv("data/kaggle_march2025_full.csv")
```

# Create Dataset for this Section
Create helper function for extracting unique elements from entries with a list of values. All lists follow the same pattern: `['el1', 'el2',...]` being `[]` for empty lists.

```{r}
# Funcion helper 
get_unique_list_values <- function(x) {
  x <- x[x != "[]"]
  x <- gsub("^\\[|\\]$", "", x) # quitar [ y ]
  x <- gsub("['\"]", "", x)# quitar ' y "
  
  elements <- strsplit(x, ",") # dividr por comas

  vals <- trimws(unlist(elements, use.names = FALSE)) # aplanar y trim
  vals <- vals[vals != ""]
  
  sort(unique(vals))
}
```

Create helper function for extracting unique tags. These are formatted differently and follow dictionary-like pattern where each element is a key-value pair being `[]` for empty entries.
```{r}
get_unique_dict_keys <- function(x) {
  x <- x[x != "[]"]
  
  keys_list <- str_extract_all(x, "(?<=')[^']+(?='\\s*:)")
  
  keys <- trimws(unlist(keys_list, use.names = FALSE))
  keys <- keys[keys != ""]
  sort(unique(keys))
}
```


## Obtain Unique values for different columns
```{r}
steam_categories <- get_unique_list_values(steam$categories)
steam_categories
```
```{r}
steam_genres <- get_unique_list_values(steam$genres)
steam_genres
```


```{r}
steam_tags <- get_unique_dict_keys(steam$tags)
steam_tags
```
From steam's Categories, Genres and Tags, 3 subsets have been created with samples interesting for this study. Given steam's laxity at classifying these values, the 3 subsets have been created with our own interpretation. Additionally, tags that reffer to non-game software have been ignored.
```{r}
#Genres
action_genre <- c(
  # Action
  "Action", "Action-Adventure", "Action RPG", "Action Roguelike", "Action RTS",
  "Arcade", "Immersive Sim", "Metroidvania", "Musou", "Sandbox", "Survival",
  "Survival Horror", "MOBA")
shooter_genre<- c(
  # Shooter
  "Arena Shooter", "Battle Royale", "Boomer Shooter", "Bullet Hell", "Extraction Shooter",
  "FPS", "Hero Shooter", "Looter Shooter", "On-Rails Shooter", "Third-Person Shooter",
  "Top-Down Shooter", "Twin Stick Shooter", "Vehicular Combat", "Naval Combat",
  "Combat Racing")
roguelike_genre <- c(
  # Roguelike
  "Rogue-like", "Rogue-lite", "Roguevania", "Traditional Roguelike",
  "Roguelike Deckbuilder", "Mystery Dungeon")
RPG_genre <- c(
  # RPG
  "RPG", "JRPG", "CRPG", "Strategy RPG", "Tactical RPG", "Otome", 
  "Dating Sim", "Visual Novel", "Interactive Fiction", "Text-Based", 
  "MMORPG", "MMO")
strategy_genre <- c(
  # Strategy
  "Strategy", "4X", "Grand Strategy", "RTS", "Real Time Tactics",
  "Turn-Based Strategy", "Tactical", "Tabletop", "Wargame", "Political Sim",
  "God Game", "Management", "Colony Sim", "City Builder", "Shop Keeper",
  "Tower Defense", "Creature Collector")
simulation_genre <- c(
  # Simulation
  "Simulation", "Automobile Sim", "Farming Sim", "Medical Sim",
  "Hobby Sim", "Life Sim", "Space Sim", "Outbreak Sim")
sport_genre <- c(
  # Sports
  "Sports", "Baseball", "Basketball", "Bowling", "Boxing", "BMX", "Cricket",
  "Football", "Football (American)", "Football (Soccer)", "Soccer",
  "Golf", "Hockey", "Mini Golf", "Motocross", "Pool", "Racing", "Rugby",
  "Skateboarding", "Skating", "Skiing", "Snowboarding", "Snooker", "Tennis",
  "Volleyball", "Wrestling", "Driving")
fighting_genre <- c(
  # Fighting
  "2D Fighter", "3D Fighter", "Fighting", "Hack and Slash", "Souls-like")
platformer_genre <- c(
  # Platformers & runners 
  "Platformer", "2D Platformer", "3D Platformer", "Precision Platformer",
  "Runner", "Open World Survival Craft")
tabletop_genre <- c(
  # Puzzle, logic, board & card games
  "Puzzle", "Puzzle-Platformer", "Logic", "Mahjong",
  "Match 3", "Tile-Matching", "Sokoban", "Solitaire", "Trivia",
  "Board Game", "Card Game", "Trading Card Game", "Hidden Object",
  "Escape Room", "Chess", "Word Game", "Point & Click")
casual_genre <- c(
  #  Casual / idle
  "Casual", "Idler", "Clicker", "Auto Battler", "Party Game", "Pinball")
horror_genre <- c(
  # Horror
  "Horror", "Psychological Horror")
music_genre <- c(
  # Music & rhythm
  "Music", "Rhythm", "Typing")
walking_sim_genre <- c(
  # Walking
  "Walking Simulator", "FMV")

genres <- list(
  action = action_genre,
  shooter = shooter_genre,
  roguelike = roguelike_genre,
  RPG = RPG_genre,
  strategy = strategy_genre,
  simulation = simulation_genre,
  sport = sport_genre,
  fighting = fighting_genre,
  platformer = platformer_genre,
  tabletop = tabletop_genre,
  casual = casual_genre,
  horror = horror_genre,
  music = music_genre,
  walking_sim = walking_sim_genre
)


#Mechanics
resource_management_mechanic <- c(
  # Economy, building, resources
  "Base-Building", "Building", "Resource Management", "Inventory Management",
  "Crafting", "Automation", "Mining", "Farming")

customization_mechanic <- c(
  # Customization
  "Gun Customization", "Character Customization")
movement_mechanic <- c(
  # Movement
  "Stealth", "Parkour", "Swordplay", "Archery", "Sniper")
physics_mechanic <- c(
  # Physics
  "Physics", "Destruction")
failure_mechanic <- c(
  # Failure
  "Permadeath", "Perma Death")
procedural_mechanic <- c(
  # Procedural
  "Procedural Generation", "Music-Based Procedural Generation")
turn_mechanic <- c(
  # Turns
  "Turn-Based", "Turn-Based Combat", "Turn-Based Tactics",
  "Real-Time", "Real-Time with Pause",
  "Time Manipulation", "Time Management", "Time Attack")
spatial_rules_mechanic <- c(
  # Spatial rules
  "Grid-Based Movement", "Hex Grid")
quicktime_events_mechanic <- c(
  # QTE
  "Quick-Time Events")
narrative_mechanic <- c(
  # Narrative logic
  "Choices Matter", "Multiple Endings", "Nonlinear")
exploration_mechanic <- c(
  # Exploration & structure
  "Exploration", "Dungeon Crawler", "Collectathon",
  "Boss Rush", "Side Scroller", "Loot")
social_mechanic <- c(
  # Social deduction
  "Social Deduction")
card_mechanic <- c(
  # Card/Deck mechanics
  "Deckbuilding", "Card Battler")
programming_mechanic <- c(
  # Programming
  "Programming", "Coding")
economy_mechanic <- c(
  # Economy
  "Trading", "Economy", "Capitalism",
  "Diplomacy")
modding_mechanic <- c(
  # Modding / creation
  "Level Editor", "Moddable", "Mod")
tutorial_mechanic <- c(
  # Tutorial
  "Tutorial")

mechanics <- list(
  resource_management = resource_management_mechanic, 
  customization = customization_mechanic, 
  movement = movement_mechanic, 
  physics = physics_mechanic, 
  failure = failure_mechanic, 
  procedural = procedural_mechanic, 
  turn = turn_mechanic,
  spatial_rules = spatial_rules_mechanic,
  quicktime_events = quicktime_events_mechanic,
  narrative = narrative_mechanic,
  exploration = exploration_mechanic,
  social = social_mechanic,
  card = card_mechanic,
  programming = programming_mechanic,
  economy = economy_mechanic,
  modding = modding_mechanic,
  tutorial = tutorial_mechanic
)

# Characteristics
camera_characteristic <- c(
  # Dimensionality & camera
  "2D", "2.5D", "3D",
  "Isometric", "Top-Down",
  "6DOF",
  "First-Person", "Third Person")

vr_characteristic <- c(
  # VR
  "VR", "VR Only", "Asymmetric VR")

players_characteristic <- c(
  # Player count / mode
  "Singleplayer",
  "Multiplayer", "Massively Multiplayer",
  "Co-op", "Local Co-Op", "Online Co-Op", "Co-op Campaign",
  "4 Player Local", "Split Screen")
team_characteristic <- c(
  # Team/role structure
  "PvP", "PvE", "Team-Based",
  "Asynchronous Multiplayer")
esports_characteristic <- c(
  # Competitive/e-sports
  "e-sports")

characteristics <- list(
  camera = camera_characteristic,
  vr = vr_characteristic,
  players = players_characteristic,
  team = team_characteristic,
  esports = esports_characteristic
)
```


Thankfully the task of filtering indie games is already provided by steam with the Tags and Genres Indie, Crowfunded and Kickstarter. From the original dataset, only Indie games are obtained.
```{r}
indie <- c("Crowdfunded", "Kickstarter", "Indie")
indie_pattern <- str_c(indie, collapse = "|")

indie_games <- steam %>% 
  filter(
    if_any(
      c(categories, genres, tags),
      ~ str_detect(.x, indie_pattern)
    )
  )
```

Prepare data for determining successful games
```{r}
indie_games_data <- indie_games %>% select(appid, name, price, dlc_count, windows, mac, linux, achievements, recommendations, supported_languages, positive, negative, estimated_owners, average_playtime_forever, median_playtime_forever, peak_ccu, pct_pos_total, num_reviews_total)



#transform suported languages into count
add_column_count <- function(df, column, new_col) {
  column_quo <- enquo(column)

  df %>%
    mutate(
      "{new_col}" := case_when(
        !!column_quo == "[]" ~ 0L,
        TRUE ~ str_count(!!column_quo, "'") %/% 2L
      )
    )
}

add_range_minmax <- function(df, column, min_column, max_column) {
  column_quo <- enquo(column)

  df %>%
    mutate(
      "{min_column}" := as.integer(str_extract(!!column_quo, "^\\s*\\d+")),
      "{max_column}" := as.integer(str_extract(!!column_quo, "\\d+\\s*$"))
    )
}

#Limpiar esta linea con los cambios de arturo TODO
indie_games_data <- indie_games_data %>% 
  add_range_minmax(estimated_owners, "estimated_owners_min", "estimated_owners_max") %>% # split owners range
  mutate(estimated_revenue = ((estimated_owners_min + estimated_owners_max) / 2) * price) %>% # augment data with revenue
  mutate(windows = as.integer(windows == "True")) %>% # parse logical to int
  mutate(mac = as.integer(mac == "True")) %>% # parse logical to int
  mutate(linux = as.integer(linux == "True")) %>% # parse logical to int
  select(-estimated_owners)
```

Cluster the data:
```{r}
indie_games_cluster <- indie_games_data %>% 
  add_column_count(supported_languages, "languages_count") %>% # Count languages
  select(-appid, -name, -supported_languages)


  indie_games_cluster <- indie_games_cluster %>% mutate( # Avoid scaling binary columns
    across(
      where(is.numeric) & !all_of(c("windows", "mac", "linux")),
      ~ as.numeric(scale(.))
    )
  )
  
  km2 <- kmeans(indie_games_cluster, centers = 3, nstart = 50)
  indie_games_data$success_cluster<- km2$cluster
  indie_games$success_cluster<- km2$cluster
  colnames(indie_games_data)
```
Obtain most discriminative variable clusters:
```{r}
vars <- c(
  "price", "dlc_count", "windows", "mac", "linux",
  "achievements", "recommendations",
  "positive", "negative",
  "average_playtime_forever", "median_playtime_forever",
  "peak_ccu",
  "pct_pos_total", "num_reviews_total",
  "estimated_owners_min", "estimated_owners_max",
  "estimated_revenue"
)

# Compute ANOVA F-statistic for each variable vs success_cluster
f_stats <- map_dbl(vars, function(v) {
  form <- as.formula(paste(v, "~ success_cluster"))
  aov_res <- aov(form, data = indie_games_data)
  summary(aov_res)[[1]][["F value"]][1]
})

# Most discriminative variable (highest F)
most_discriminative_var <- vars[which.max(f_stats)]

```
Plot the clusters using the most discriminative variable:
```{r}
recommendations_by_cluster <- indie_games_data %>%
  group_by(success_cluster) %>%
  summarise(
    mean_val = mean(as.numeric(.data[[most_discriminative_var]])),
    median_val = median(as.numeric(.data[[most_discriminative_var]])),
    n_games = n(),
    .groups = "drop"
  )

ggplot(recommendations_by_cluster,
       aes(x = factor(success_cluster), y = mean_val)) +
  geom_col() +
  geom_text(aes(label = n_games), vjust = -0.4) +
  scale_y_continuous(
    breaks = scales::pretty_breaks(),
    expand = expansion(mult = c(0, 0.16))) +
  labs(
    x = "Cluster",
    y = paste("Average", most_discriminative_var),
    title = paste("Average", most_discriminative_var, "by cluster")
  )
```
Tag each game depending on if it pertains to a successful cluster or not:
```{r}
# Find the 2 clusters with the highest mean of the most discriminative variable
top2_clusters <- recommendations_by_cluster %>%
  arrange(desc(mean_val)) %>%
  slice_head(n = 2) %>%
  pull(success_cluster)

# Add successful column (1 if in top 2 clusters, else 0)
indie_games <- indie_games %>%
  mutate(successful = success_cluster %in% top2_clusters) %>%
  select(-success_cluster)
```




Helper functions for generating the one-hot encoded variables for the genres, characteristics and mechanics:
```{r}
  make_value_one_hot <- function(data, values, categories_col = "categories", genres_col = "genres", tags_col = "tags") {
  
  # Modified version of get_unique_list_values
  parse_list_row <- function(x) {
    if (x == "[]") return(character(0))
    
    x <- gsub("^\\[|\\]$", "", x) # quitar [ y ]
    x <- gsub("['\"]", "", x)     # quitar ' y "
    
    elements <- strsplit(x, ",")[[1]]
    vals <- trimws(elements)
    vals <- vals[vals != ""]
    vals
  }
  
  # Modified version of get_unique_dict_keys
  parse_dict_row <- function(x) {
    if (x == "[]" || x == "") return(character(0))
    
    m <- gregexpr("'[^']+'(?='\\s*:)", x, perl = TRUE)
    keys <- regmatches(x, m)[[1]]
    if (length(keys) == 0) return(character(0))
    
    keys <- gsub("^'|'$", "", keys)
    keys <- trimws(keys)
    keys[keys != ""]
  }
  
  # Precompute  tokens per game (categories + genres + tags)
  tokens_list <- lapply(seq_len(nrow(data)), function(i) {
    cats <- parse_list_row(data[[categories_col]][i])
    gens <- parse_list_row(data[[genres_col]][i])
    tgs  <- parse_dict_row(data[[tags_col]][i])
    
    unique(c(cats, gens, tgs))
  })
  
  # For each  value, create a one-hot column
  for (val in values) {
    data[[val]] <- vapply(
      tokens_list,
      function(tokens) val %in% tokens,
      logical(1)
    )
  }
  
  data
  }

make_group_flag <- function(data, values, group_name,
                            categories_col = "categories",
                            genres_col = "genres",
                            tags_col = "tags") {

  parse_list_row <- function(x) {
    x <- as.character(x)
    if (is.na(x) || x == "[]") return(character(0))
    x <- gsub("^\\[|\\]$", "", x)
    x <- gsub("['\"]", "", x)
    vals <- trimws(strsplit(x, ",", fixed = TRUE)[[1]])
    vals[vals != ""]
  }

  parse_dict_row <- function(x) {
    x <- as.character(x)
    if (is.na(x) || x == "[]" || x == "" || x == "{}") return(character(0))

    m <- gregexpr("(['\"])([^'\"]+)\\1\\s*:", x, perl = TRUE)
    pieces <- regmatches(x, m)[[1]]
    if (length(pieces) == 0) return(character(0))

    keys <- sub("^(['\"])([^'\"]+)\\1\\s*:$", "\\2", pieces, perl = TRUE)
    keys <- trimws(keys)
    keys[keys != ""]
  }

  values_set <- trimws(unique(values))

  tokens_list <- lapply(seq_len(nrow(data)), function(i) {
    cats <- parse_list_row(data[[categories_col]][i])
    gens <- parse_list_row(data[[genres_col]][i])
    tgs  <- parse_dict_row(data[[tags_col]][i])
    tokens <- unique(c(cats, gens, tgs))
    tokens
  })

  flag <- vapply(tokens_list, function(tokens) any(tokens %in% values_set), logical(1))

  data[[group_name]] <- flag

  data
}


```

From the indie_games dataset, the games and their genres, characteristics and mechanics are turned into transactions
```{r}
indie_games_attributes <- indie_games %>% select(tags, categories, genres, successful)

successful_indie_games_attributes <- indie_games_attributes %>%
  filter(successful == TRUE) %>%
  select(-successful)

# Generate or load Genres dataset
out_file <- file.path("data", "indie_games_genre.rds")

if (file.exists(out_file)) {
  indie_games_genre <- readRDS(out_file)
} else {
  dir.create("data", showWarnings = FALSE, recursive = TRUE)

  indie_games_genre <- successful_indie_games_attributes
  for (nm in names(genres)) {
    indie_games_genre <- make_group_flag(
      data = indie_games_genre,
      values = genres[[nm]],
      group_name = nm
    )
  }
  indie_games_genre <- indie_games_genre %>% select(-tags, -categories, -genres)

  saveRDS(indie_games_genre, out_file)
}

# Generate or load Mechanics dataset
out_file <- file.path("data", "indie_games_mechanic.rds")

if (file.exists(out_file)) {
  indie_games_mechanic <- readRDS(out_file)
} else {
  dir.create("data", showWarnings = FALSE, recursive = TRUE)

  indie_games_mechanic <- successful_indie_games_attributes
  for (nm in names(mechanics)) {
    indie_games_mechanic <- make_group_flag( 
      data = indie_games_mechanic,
      values = mechanics[[nm]],
      group_name = nm
    )
  }
  indie_games_mechanic <- indie_games_mechanic %>% select(-tags, -categories, -genres)
  
  saveRDS(indie_games_mechanic, out_file)
}

# Generate or load characteristics dataset
characteristics_flat <-unlist(characteristics)
out_file <- file.path("data", "indie_games_characteristic.rds")

if (file.exists(out_file)) {
  indie_games_characteristic <- readRDS(out_file)
} else {
  dir.create("data", showWarnings = FALSE, recursive = TRUE)

  indie_games_characteristic <- successful_indie_games_attributes %>%
    make_value_one_hot(characteristics_flat) %>% 
    select(-tags, -categories, -genres)
  
  saveRDS(indie_games_characteristic, out_file)
}

trans_indie_games_genre <- as(indie_games_genre, "transactions")
trans_indie_games_mechanic<- as(indie_games_mechanic, "transactions")
trans_indie_games_characteristic <- as(indie_games_characteristic, "transactions")
```

```{r}
genre_itemsets <- eclat(trans_indie_games_genre, parameter = list(support = 0.10, minlen = 2, maxlen = 4))

genre_top <- head(sort(genre_itemsets, by = "support"), 30)
genre_df <- as(genre_top, "data.frame")

barplot(
  height = genre_df$support,
  names.arg = genre_df$items,
  las = 2, cex.names = 0.7,
  main = "Top genre combinations (support)",
  ylab = "Support"
)
```

Plot counts
```{r}
indie_games_genre %>%
  pivot_longer(cols = everything(),
               names_to = "genre",
               values_to = "has_genre") %>%
  group_by(genre) %>%
  summarise(count = sum(as.integer(has_genre), na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(count)) %>%
  ggplot(aes(x = genre, y = count)) +
  geom_col() +
  coord_flip() +
  labs(title = "Successful indie games — Genre counts", x = NULL, y = "Games") +
  theme_minimal()
```


Asociation rules for mechanics:
```{r}
trans_g <- trans_indie_games_genre
trans_m <- trans_indie_games_mechanic

# Combine genres+mechanics per game
g_list <- LIST(trans_g)
m_list <- LIST(trans_m)

gm_list  <- Map(c, g_list, m_list)
trans_gm <- as(gm_list, "transactions")

top_genre_list <- LIST(items(genre_top))

# Mine rules: GENRES (LHS) -> MECHANICS (RHS)
rules_gm <- apriori(
  trans_gm,
  parameter  = list(supp = 0.01, conf = 0.30, minlen = 3, maxlen = 5, target = "rules"),
  appearance = list(
    default = "none",
    lhs = itemLabels(trans_g),
    rhs = itemLabels(trans_m)
  ),
  control = list(verbose = FALSE)
)

# --- 5) For each top genre combo, pull the best mechanics (e.g., by lift) ---
lhs_keys <- vapply(LIST(lhs(rules_gm)), function(x) paste(sort(x), collapse="|"), "")

get_rules_for_combo <- function(gset, n = 10, by = "lift") {
  key <- paste(sort(gset), collapse="|")
  rg <- rules_gm[lhs_keys == key]
  if (length(rg) == 0) return(NULL)
  rg <- sort(rg, by = by, decreasing = TRUE)
  head(rg, n)
}

out <- do.call(rbind, lapply(top_genre_list, function(gset) {
  rg <- get_rules_for_combo(gset, n = 10, by = "lift")
  if (is.null(rg)) return(NULL)

  df <- as(rg, "data.frame")
  df$genre_combo <- paste(sub("^G:", "", gset), collapse = " + ")
  df$mechanic <- sub("^M:", "", unlist(LIST(rhs(rg))))
  df[, c("genre_combo", "mechanic", "support", "confidence", "lift")]
}))

out
```
```{r}
# your top genre combos (as list of vectors)
top_genre_list <- LIST(items(genre_top))

# build keys for quick exact matching
top_keys <- vapply(top_genre_list, function(x) paste(sort(x), collapse="|"), "")
lhs_keys <- vapply(LIST(lhs(rules_gm)), function(x) paste(sort(x), collapse="|"), "")

# keep rules whose LHS matches one of the top genre combos
rules_sel <- rules_gm[lhs_keys %in% top_keys]

plot(
  rules_sel,
  method = "scatterplot",
  measure = c("support", "confidence"),
  shading = "lift",
)
```

Plot mechanic counts:
```{r}
indie_games_mechanic %>%
  pivot_longer(cols = everything(),
               names_to = "mechanic",
               values_to = "has_mechanic") %>%
  group_by(mechanic) %>%
  summarise(count = sum(as.integer(has_mechanic), na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(count)) %>%
  ggplot(aes(x = mechanic, y = count)) +
  geom_col() +
  coord_flip() +
  labs(title = "Successful indie games — Mechanic counts", x = NULL, y = "Games") +
  theme_minimal()
```

study characteristics:

```{r}
characteristic_itemsets <- eclat(trans_indie_games_characteristic, parameter = list(support = 0.001, minlen = 2))

characteristic_top <- head(sort(characteristic_itemsets, by = "support"), 30)
characteristic_df <- as(characteristic_top, "data.frame")

barplot(
  height = characteristic_df$support,
  names.arg = characteristic_df$items,
  las = 2, cex.names = 0.7,
  main = "Top characteristic combinations (support)",
  ylab = "Support"
)
```

```{r}
indie_games_regression <- indie_games_data %>%
  mutate(
    owners_min = as.numeric(estimated_owners_min),
    owners_max = as.numeric(estimated_owners_max),
    owners_mid = (owners_min + owners_max) / 2,
    log_owners = log1p(owners_mid),
    log_price  = log1p(price)
  )
    
ggplot(indie_games_regression, aes(x = price, y = owners_mid)) +
  geom_point(alpha = 0.08) +
  scale_x_continuous(trans = "log1p") +
  scale_y_continuous(trans = "log1p") +
  geom_smooth(method = "lm", se = TRUE)
  
```

```{r}
cor.test(indie_games_regression$log_price, indie_games_regression$log_owners, method = "spearman")
```

```{r}
paid <- indie_games_regression %>% filter(price > 0)

m <- lm(log_owners ~ log_price, data = paid)
summary(m)
```

